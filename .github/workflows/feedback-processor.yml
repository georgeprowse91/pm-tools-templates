name: Community Feedback Processor
on:
  issue_comment:
    types: [created]
  issues:
    types: [opened, labeled]

jobs:
  process-feedback:
    if: >
      (github.event.issue.number == 198) || 
      (contains(github.event.issue.labels.*.name, 'community-feedback')) ||
      (github.event.action == 'opened' && contains(github.event.issue.body, '## üéâ Positive Feedback')) ||
      (github.event.action == 'opened' && contains(github.event.issue.body, '## üîß Improvement Suggestion')) ||
      (github.event.action == 'opened' && contains(github.event.issue.body, '## üí° Feature Request'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Parse Feedback Content
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            // Extract feedback data from comment or issue
            let feedbackContent = '';
            let feedbackAuthor = '';
            let feedbackUrl = '';
            
            if (context.eventName === 'issue_comment') {
              feedbackContent = context.payload.comment.body;
              feedbackAuthor = context.payload.comment.user.login;
              feedbackUrl = context.payload.comment.html_url;
            } else if (context.eventName === 'issues') {
              feedbackContent = context.payload.issue.body;
              feedbackAuthor = context.payload.issue.user.login;
              feedbackUrl = context.payload.issue.html_url;
            }

            // Parse structured feedback templates
            const feedbackTypes = {
              'positive': /## üéâ Positive Feedback/i,
              'improvement': /## üîß Improvement Suggestion/i,
              'feature': /## üí° Feature Request/i,
              'bug': /## üêõ Issues & Bugs/i,
              'documentation': /## üìö Documentation Feedback/i
            };

            let detectedType = 'general';
            for (const [type, regex] of Object.entries(feedbackTypes)) {
              if (regex.test(feedbackContent)) {
                detectedType = type;
                break;
              }
            }

            const feedbackData = {
              id: `feedback-${Date.now()}`,
              type: detectedType,
              author: feedbackAuthor,
              content: feedbackContent,
              url: feedbackUrl,
              timestamp: new Date().toISOString(),
              issue_number: context.payload.issue.number
            };

            console.log('Parsed feedback:', JSON.stringify(feedbackData, null, 2));
            return feedbackData;

      - name: AI Classification
        id: classify
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const feedbackData = ${{ steps.parse.outputs.result }};
            
            // Classification logic based on content analysis
            const content = feedbackData.content.toLowerCase();
            let category = 'general';
            let priority = 'S3';

            // Category classification
            if (content.includes('template') || content.includes('example')) {
              category = 'template-requests';
            } else if (content.includes('bug') || content.includes('error') || content.includes('broken')) {
              category = 'bug-reports';
              priority = 'S2';
            } else if (content.includes('integration') || content.includes('jira') || content.includes('asana')) {
              category = 'integration-requests';
            } else if (content.includes('documentation') || content.includes('guide') || content.includes('readme')) {
              category = 'documentation-issues';
            } else if (content.includes('performance') || content.includes('slow') || content.includes('automation')) {
              category = 'performance-automation';
            } else if (content.includes('ui') || content.includes('ux') || content.includes('design') || content.includes('usability')) {
              category = 'ux-usability';
            } else if (feedbackData.type === 'feature') {
              category = 'feature-ideas';
            } else if (feedbackData.type === 'improvement') {
              category = 'process-improvements';
            }

            // Priority scoring based on keywords
            if (content.includes('critical') || content.includes('urgent') || content.includes('blocking')) {
              priority = 'S1';
            } else if (content.includes('important') || content.includes('needed') || feedbackData.type === 'bug') {
              priority = 'S2';
            } else if (content.includes('nice to have') || content.includes('suggestion')) {
              priority = 'S4';
            }

            const classification = {
              category: category,
              priority: priority,
              confidence: 0.8
            };

            console.log('Classification result:', JSON.stringify(classification, null, 2));
            return JSON.stringify(classification);

      - name: Check if Already Processed
        id: check_processing
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.FEEDBACK_PROCESSOR_TOKEN }}
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Get existing comments to check if already processed
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            // Check if we already have a processing comment
            const hasProcessingComment = comments.data.some(comment => 
              comment.body.includes('ü§ñ Automated Feedback Processing')
            );
            
            if (hasProcessingComment) {
              console.log(`Issue #${issueNumber} already processed - skipping duplicate processing`);
              return { skip: true };
            }
            
            console.log(`Issue #${issueNumber} not yet processed - proceeding`);
            return { skip: false };

      - name: Route to Epic
        id: route
        if: fromJSON(steps.check_processing.outputs.result).skip == false
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.FEEDBACK_PROCESSOR_TOKEN }}
          script: |
            const feedbackData = ${{ steps.parse.outputs.result }};
            const classification = JSON.parse(`${{ steps.classify.outputs.result }}`);
            
            console.log('Processing feedback - not a duplicate');
            
            // Epic mapping based on categories
            const epicMapping = {
              'template-requests': { epic: 323, theme: 'User Experience & Interface Enhancement' },
              'bug-reports': { epic: 307, theme: 'Technical Debt & Quality' },
              'integration-requests': { epic: 325, theme: 'Integration & Automation Platform' },
              'documentation-issues': { epic: 323, theme: 'User Experience & Interface Enhancement' },
              'performance-automation': { epic: 329, theme: 'Quality & Operations Excellence' },
              'ux-usability': { epic: 323, theme: 'User Experience & Interface Enhancement' },
              'feature-ideas': { epic: 317, theme: 'AI & Data Science Intelligence' },
              'process-improvements': { epic: 322, theme: 'Quality & Operations Excellence' }
            };

            const routing = epicMapping[classification.category] || { epic: 198, theme: 'General Feedback' };
            
            // Retry function with exponential backoff
            async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 2000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  console.log(`Attempt ${attempt} failed:`, error.message);
                  
                  // Check if it's a rate limit error
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    if (attempt === maxRetries) {
                      throw error; // Final attempt failed
                    }
                    
                    // Exponential backoff: 2s, 4s, 8s
                    const delay = baseDelay * Math.pow(2, attempt - 1);
                    console.log(`Rate limit hit. Waiting ${delay}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                  } else {
                    throw error; // Non-rate-limit error, don't retry
                  }
                }
              }
            }
            
            // Create comment with routing information
            const routingComment = `
            ## ü§ñ Automated Feedback Processing
            
            **Feedback Classification:**
            - **Type:** ${feedbackData.type}
            - **Category:** ${classification.category}
            - **Priority:** ${classification.priority}
            - **Confidence:** ${(classification.confidence * 100).toFixed(0)}%
            
            **Routing Decision:**
            - **Epic:** #${routing.epic} - ${routing.theme}
            - **Processing Time:** ${new Date().toISOString()}
            - **Status:** Routed for review
            
            **Next Steps:**
            1. Epic owner will be notified
            2. Feedback will be considered for upcoming sprint planning
            3. Updates will be provided on resolution progress
            
            *This is an automated response from the Community Feedback Processing System.*
            `;

            // Add comment to the issue with retry logic
            console.log('Adding feedback processing comment...');
            await retryWithBackoff(async () => {
              return await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: feedbackData.issue_number,
                body: routingComment
              });
            });

            // Add labels based on classification with retry logic
            const labels = [
              'community-feedback',
              `category:${classification.category}`,
              `priority:${classification.priority}`,
              `epic:${routing.epic}`
            ];

            console.log('Adding classification labels...');
            await retryWithBackoff(async () => {
              return await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: feedbackData.issue_number,
                labels: labels
              });
            });

            console.log('Successfully processed feedback with routing and labeling.');
            return {
              routing: routing,
              classification: classification,
              labels: labels
            };

      - name: Notify Stakeholders
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.FEEDBACK_PROCESSOR_TOKEN }}
          script: |
            const routingResult = ${{ steps.route.outputs.result }};
            const feedbackData = ${{ steps.parse.outputs.result }};
            
            // Retry function with exponential backoff (same as in Route to Epic step)
            async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 2000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  console.log(`Notification attempt ${attempt} failed:`, error.message);
                  
                  // Check if it's a rate limit error
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    if (attempt === maxRetries) {
                      console.log('Final notification attempt failed due to rate limits');
                      return null; // Don't throw - this is a non-critical step
                    }
                    
                    // Exponential backoff with jitter to avoid thundering herd
                    const delay = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000;
                    console.log(`Rate limit hit during notification. Waiting ${Math.round(delay)}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                  } else {
                    console.log('Non-rate-limit error during notification:', error.message);
                    return null; // Don't throw - this is a non-critical step
                  }
                }
              }
            }
            
            // Create notification comment on the relevant epic
            if (routingResult.routing.epic !== 198) {
              const notificationComment = `
              ## üì¨ New Community Feedback Routed Here
              
              **Feedback Summary:**
              - **Author:** @${feedbackData.author}
              - **Type:** ${feedbackData.type}
              - **Priority:** ${routingResult.classification.priority}
              - **Source:** [Feedback #${feedbackData.issue_number}](${feedbackData.url})
              
              **Action Required:**
              Epic owner please review and consider for sprint planning.
              
              *Automated notification from Community Feedback Processing System*
              `;

              console.log(`Sending notification to epic #${routingResult.routing.epic}...`);
              const result = await retryWithBackoff(async () => {
                return await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: routingResult.routing.epic,
                  body: notificationComment
                });
              });
              
              if (result) {
                console.log(`‚úÖ Notification successfully sent to epic #${routingResult.routing.epic}`);
              } else {
                console.log(`‚ö†Ô∏è Could not send notification to epic #${routingResult.routing.epic} (will continue processing)`);
              }
            } else {
              console.log('Skipping epic notification - feedback routed to general feedback epic #198');
            }

      - name: Update Analytics
        uses: actions/github-script@v7
        with:
          script: |
            const feedbackData = ${{ steps.parse.outputs.result }};
            const classification = JSON.parse(`${{ steps.classify.outputs.result }}`);
            
            // Log analytics data (in a real implementation, this would go to a database)
            const analyticsEntry = {
              timestamp: new Date().toISOString(),
              type: feedbackData.type,
              category: classification.category,
              priority: classification.priority,
              author: feedbackData.author,
              processing_time: Date.now() - new Date(feedbackData.timestamp).getTime()
            };
            
            console.log('Analytics entry:', JSON.stringify(analyticsEntry, null, 2));
            
            // Store in artifact for later analysis
            const fs = require('fs');
            const analyticsFile = 'feedback-analytics.jsonl';
            const entry = JSON.stringify(analyticsEntry) + '\n';
            
            if (fs.existsSync(analyticsFile)) {
              fs.appendFileSync(analyticsFile, entry);
            } else {
              fs.writeFileSync(analyticsFile, entry);
            }

      - name: Upload Analytics Data
        uses: actions/upload-artifact@v4
        with:
          name: feedback-analytics-${{ github.run_id }}
          path: feedback-analytics.jsonl
          retention-days: 30
