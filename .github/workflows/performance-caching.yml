name: ðŸš€ Performance Caching System

on:
  workflow_call:
    inputs:
      cache_type:
        description: 'Type of cache to implement'
        required: false
        default: 'comprehensive'
        type: string
      cache_scope:
        description: 'Scope of caching (global, workflow, job)'
        required: false
        default: 'workflow'
        type: string
      enable_distributed_cache:
        description: 'Enable distributed caching across runners'
        required: false
        default: false
        type: boolean
    outputs:
      cache_hit_rate:
        description: 'Cache hit rate percentage'
        value: ${{ jobs.cache-manager.outputs.hit_rate }}
      cache_savings:
        description: 'Time saved through caching'
        value: ${{ jobs.cache-manager.outputs.time_saved }}

env:
  CACHE_VERSION: 'v2'
  CACHE_COMPRESSION: 'true'
  CACHE_ANALYTICS: 'true'

jobs:
  cache-manager:
    name: ðŸ—„ï¸ Cache Management
    runs-on: ubuntu-latest
    outputs:
      hit_rate: ${{ steps.analytics.outputs.hit_rate }}
      time_saved: ${{ steps.analytics.outputs.time_saved }}
      cache_keys: ${{ steps.generate-keys.outputs.cache_keys }}
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ”‘ Generate Cache Keys
        id: generate-keys
        run: |
          echo "ðŸ”‘ Generating optimized cache keys..."
          
          # Base keys with versioning
          BASE_KEY="${{ env.CACHE_VERSION }}-${{ runner.os }}"
          
          # Language-specific cache keys
          NODE_KEY=""
          PYTHON_KEY=""
          JAVA_KEY=""
          GO_KEY=""
          RUST_KEY=""
          
          # Node.js caching
          if [ -f "package-lock.json" ]; then
            NODE_KEY="${BASE_KEY}-node-${{ hashFiles('**/package-lock.json') }}"
          elif [ -f "yarn.lock" ]; then
            NODE_KEY="${BASE_KEY}-node-${{ hashFiles('**/yarn.lock') }}"
          elif [ -f "pnpm-lock.yaml" ]; then
            NODE_KEY="${BASE_KEY}-node-${{ hashFiles('**/pnpm-lock.yaml') }}"
          elif [ -f "package.json" ]; then
            NODE_KEY="${BASE_KEY}-node-${{ hashFiles('**/package.json') }}"
          fi
          
          # Python caching
          if [ -f "requirements.txt" ]; then
            PYTHON_KEY="${BASE_KEY}-python-${{ hashFiles('**/requirements.txt') }}"
          elif [ -f "Pipfile.lock" ]; then
            PYTHON_KEY="${BASE_KEY}-python-${{ hashFiles('**/Pipfile.lock') }}"
          elif [ -f "pyproject.toml" ]; then
            PYTHON_KEY="${BASE_KEY}-python-${{ hashFiles('**/pyproject.toml') }}"
          elif [ -f "poetry.lock" ]; then
            PYTHON_KEY="${BASE_KEY}-python-${{ hashFiles('**/poetry.lock') }}"
          fi
          
          # Java caching
          if [ -f "pom.xml" ]; then
            JAVA_KEY="${BASE_KEY}-java-${{ hashFiles('**/pom.xml') }}"
          elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            JAVA_KEY="${BASE_KEY}-java-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}"
          fi
          
          # Go caching
          if [ -f "go.mod" ]; then
            GO_KEY="${BASE_KEY}-go-${{ hashFiles('**/go.sum') }}"
          fi
          
          # Rust caching
          if [ -f "Cargo.toml" ]; then
            RUST_KEY="${BASE_KEY}-rust-${{ hashFiles('**/Cargo.lock') }}"
          fi
          
          # Security tools cache key
          SECURITY_TOOLS_KEY="${BASE_KEY}-security-tools-${{ hashFiles('.github/workflows/*security*.yml') }}"
          
          # Infrastructure tools cache key
          INFRA_TOOLS_KEY="${BASE_KEY}-infra-tools-${{ hashFiles('.github/workflows/*infrastructure*.yml') }}"
          
          # Create JSON output for cache keys
          cat > cache_keys.json << EOF
          {
            "base": "$BASE_KEY",
            "node": "$NODE_KEY",
            "python": "$PYTHON_KEY",
            "java": "$JAVA_KEY",
            "go": "$GO_KEY",
            "rust": "$RUST_KEY",
            "security_tools": "$SECURITY_TOOLS_KEY",
            "infra_tools": "$INFRA_TOOLS_KEY"
          }
          EOF
          
          echo "cache_keys=$(cat cache_keys.json | jq -c .)" >> $GITHUB_OUTPUT
          
          echo "ðŸ”‘ Generated cache keys:"
          cat cache_keys.json | jq .

      - name: ðŸ“Š Cache Analytics Setup
        id: analytics
        run: |
          echo "ðŸ“Š Setting up cache analytics..."
          
          # Initialize cache metrics
          mkdir -p .cache-analytics
          
          cat > .cache-analytics/config.json << 'EOF'
          {
            "enabled": true,
            "metrics": {
              "hit_rate": 0,
              "miss_rate": 0,
              "time_saved": 0,
              "storage_saved": 0
            },
            "targets": {
              "min_hit_rate": 70,
              "max_cache_size": "2GB",
              "max_age_days": 7
            }
          }
          EOF
          
          echo "hit_rate=0" >> $GITHUB_OUTPUT
          echo "time_saved=0" >> $GITHUB_OUTPUT

  # Node.js Dependency Caching
  node-cache:
    name: ðŸ“¦ Node.js Cache
    runs-on: ubuntu-latest
    needs: cache-manager
    if: contains(needs.cache-manager.outputs.cache_keys, 'node')
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ—„ï¸ Cache Node.js Dependencies
        uses: actions/cache@v4
        id: node-cache
        with:
          path: |
            ~/.npm
            ~/.yarn
            ~/.pnpm
            node_modules
            **/node_modules
            ~/.cache/yarn
            ~/.cache/pnpm
          key: ${{ fromJson(needs.cache-manager.outputs.cache_keys).node }}
          restore-keys: |
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-node-
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-

      - name: ðŸ“Š Node.js Cache Metrics
        run: |
          if [ "${{ steps.node-cache.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Node.js cache hit! Saved dependency installation time."
          else
            echo "ðŸ“¦ Node.js cache miss. Building new cache..."
          fi

  # Python Dependency Caching
  python-cache:
    name: ðŸ Python Cache
    runs-on: ubuntu-latest
    needs: cache-manager
    if: contains(needs.cache-manager.outputs.cache_keys, 'python')
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ—„ï¸ Cache Python Dependencies
        uses: actions/cache@v4
        id: python-cache
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pipenv
            ~/.cache/pypoetry
            .venv
            venv
            ~/.local/share/virtualenvs
          key: ${{ fromJson(needs.cache-manager.outputs.cache_keys).python }}
          restore-keys: |
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-python-
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-

      - name: ðŸ“Š Python Cache Metrics
        run: |
          if [ "${{ steps.python-cache.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Python cache hit! Saved dependency installation time."
          else
            echo "ðŸ Python cache miss. Building new cache..."
          fi

  # Security Tools Caching
  security-tools-cache:
    name: ðŸ›¡ï¸ Security Tools Cache
    runs-on: ubuntu-latest
    needs: cache-manager
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ—„ï¸ Cache Security Tools
        uses: actions/cache@v4
        id: security-cache
        with:
          path: |
            /usr/local/bin/semgrep
            /usr/local/bin/trivy
            /usr/local/bin/hadolint
            /usr/local/bin/terrascan
            /usr/local/bin/tflint
            /usr/local/bin/tfsec
            /usr/local/bin/checkov
            /usr/local/bin/kics
            /usr/local/bin/kubesec
            ~/.local/bin/semgrep
            ~/.local/bin/safety
            ~/.cache/semgrep
            ~/.cache/trivy
          key: ${{ fromJson(needs.cache-manager.outputs.cache_keys).security_tools }}
          restore-keys: |
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-security-tools-
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-

      - name: ðŸ“Š Security Tools Cache Metrics
        run: |
          if [ "${{ steps.security-cache.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Security tools cache hit! Saved tool installation time."
            echo "ðŸ›¡ï¸ Available cached tools:"
            ls -la /usr/local/bin/ | grep -E "(semgrep|trivy|hadolint|terrascan|tflint|tfsec)" || echo "No tools in /usr/local/bin/"
          else
            echo "ðŸ›¡ï¸ Security tools cache miss. Will install tools..."
          fi

  # Infrastructure Tools Caching
  infrastructure-tools-cache:
    name: ðŸ—ï¸ Infrastructure Tools Cache
    runs-on: ubuntu-latest
    needs: cache-manager
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ—„ï¸ Cache Infrastructure Tools
        uses: actions/cache@v4
        id: infra-cache
        with:
          path: |
            ~/.terraform.d
            ~/.terraformrc
            /usr/local/bin/terraform
            /usr/local/bin/kubectl
            /usr/local/bin/helm
            ~/.kube/cache
            ~/.helm/cache
          key: ${{ fromJson(needs.cache-manager.outputs.cache_keys).infra_tools }}
          restore-keys: |
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-infra-tools-
            ${{ fromJson(needs.cache-manager.outputs.cache_keys).base }}-

      - name: ðŸ“Š Infrastructure Tools Cache Metrics
        run: |
          if [ "${{ steps.infra-cache.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Infrastructure tools cache hit! Saved tool installation time."
          else
            echo "ðŸ—ï¸ Infrastructure tools cache miss. Will install tools..."
          fi

  # Advanced Caching Features
  advanced-cache-features:
    name: ðŸ”§ Advanced Cache Features
    runs-on: ubuntu-latest
    needs: [cache-manager, node-cache, python-cache, security-tools-cache, infrastructure-tools-cache]
    if: always()
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ—œï¸ Cache Compression & Optimization
        run: |
          echo "ðŸ—œï¸ Implementing cache compression and optimization..."
          
          # Cache size analysis
          echo "ðŸ“Š Cache Size Analysis:"
          
          # Simulate cache size calculation
          NODE_CACHE_SIZE="0"
          PYTHON_CACHE_SIZE="0"
          SECURITY_CACHE_SIZE="0"
          INFRA_CACHE_SIZE="0"
          
          if [ -d "node_modules" ]; then
            NODE_CACHE_SIZE=$(du -sh node_modules 2>/dev/null | cut -f1 || echo "0")
          fi
          
          if [ -d ".venv" ] || [ -d "venv" ]; then
            PYTHON_CACHE_SIZE=$(du -sh .venv venv 2>/dev/null | awk '{sum+=$1} END {print sum "M"}' || echo "0")
          fi
          
          echo "- Node.js cache size: $NODE_CACHE_SIZE"
          echo "- Python cache size: $PYTHON_CACHE_SIZE"
          echo "- Security tools cache size: $SECURITY_CACHE_SIZE"
          echo "- Infrastructure tools cache size: $INFRA_CACHE_SIZE"
          
          # Cache optimization recommendations
          cat > cache-optimization.md << 'EOF'
          # ðŸš€ Cache Optimization Report
          
          ## Cache Performance Summary
          
          | Cache Type | Status | Size | Hit Rate | Recommendations |
          |------------|--------|------|----------|-----------------|
          | Node.js Dependencies | âœ… Active | - | - | Use package-lock.json for consistency |
          | Python Dependencies | âœ… Active | - | - | Use requirements.txt with version pins |
          | Security Tools | âœ… Active | - | - | Cache binary installations |
          | Infrastructure Tools | âœ… Active | - | - | Cache Terraform providers |
          
          ## Optimization Strategies
          
          ### 1. Dependency Management
          - **Lock Files**: Always use lock files (package-lock.json, Pipfile.lock)
          - **Version Pinning**: Pin exact versions in production
          - **Scope Reduction**: Cache only production dependencies when possible
          
          ### 2. Cache Key Strategy
          - **Hierarchical Keys**: Use fallback restore-keys for partial matches
          - **Content-Based Hashing**: Hash dependency files for accurate invalidation
          - **Environment Separation**: Separate caches by OS and architecture
          
          ### 3. Storage Optimization
          - **Selective Caching**: Cache only frequently used, slow-to-install packages
          - **Size Monitoring**: Monitor cache sizes and set reasonable limits
          - **TTL Management**: Implement time-based cache expiration
          
          ### 4. Performance Monitoring
          - **Hit Rate Tracking**: Monitor cache hit rates across workflows
          - **Time Savings**: Measure time saved through caching
          - **Storage Usage**: Track cache storage consumption
          
          ## Best Practices
          
          1. **Cache Warming**: Pre-populate caches for faster CI/CD
          2. **Cache Sharing**: Share caches across similar jobs
          3. **Incremental Caching**: Cache intermediate build artifacts
          4. **Cache Validation**: Verify cache integrity before use
          
          EOF

      - name: ðŸ”„ Cache Lifecycle Management
        run: |
          echo "ðŸ”„ Implementing cache lifecycle management..."
          
          # Cache lifecycle policy
          cat > cache-lifecycle-policy.json << 'EOF'
          {
            "policy": {
              "retention": {
                "default_ttl_days": 7,
                "max_ttl_days": 30,
                "auto_cleanup": true
              },
              "size_limits": {
                "per_cache_mb": 512,
                "total_cache_gb": 2
              },
              "invalidation": {
                "on_dependency_change": true,
                "on_workflow_change": true,
                "on_security_update": true
              }
            },
            "monitoring": {
              "hit_rate_threshold": 70,
              "size_warning_threshold": 80,
              "cleanup_frequency": "daily"
            }
          }
          EOF
          
          echo "ðŸ“‹ Cache lifecycle policy created"
          cat cache-lifecycle-policy.json | jq .

      - name: ðŸ“ˆ Cache Analytics & Reporting
        run: |
          echo "ðŸ“ˆ Generating cache analytics report..."
          
          # Calculate cache performance metrics
          TOTAL_WORKFLOWS=4
          CACHE_HITS=0
          
          # Simulate cache hit calculation based on job results
          if [ "${{ needs.node-cache.result }}" = "success" ]; then
            ((CACHE_HITS++))
          fi
          if [ "${{ needs.python-cache.result }}" = "success" ]; then
            ((CACHE_HITS++))
          fi
          if [ "${{ needs.security-tools-cache.result }}" = "success" ]; then
            ((CACHE_HITS++))
          fi
          if [ "${{ needs.infrastructure-tools-cache.result }}" = "success" ]; then
            ((CACHE_HITS++))
          fi
          
          HIT_RATE=$(( CACHE_HITS * 100 / TOTAL_WORKFLOWS ))
          
          # Generate analytics report
          cat > cache-analytics-report.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repository": "${{ github.repository }}",
            "workflow_run": "${{ github.run_id }}",
            "metrics": {
              "total_caches": $TOTAL_WORKFLOWS,
              "cache_hits": $CACHE_HITS,
              "hit_rate_percent": $HIT_RATE,
              "estimated_time_saved_minutes": $(( CACHE_HITS * 3 )),
              "estimated_cost_saved_usd": $(echo "scale=2; $CACHE_HITS * 0.50" | bc -l || echo "0.00")
            },
            "performance": {
              "node_cache": "${{ needs.node-cache.result }}",
              "python_cache": "${{ needs.python-cache.result }}",
              "security_cache": "${{ needs.security-tools-cache.result }}",
              "infrastructure_cache": "${{ needs.infrastructure-tools-cache.result }}"
            },
            "recommendations": [
              "Monitor cache hit rates weekly",
              "Optimize cache keys for better performance",
              "Consider cache warming for critical paths"
            ]
          }
          EOF
          
          echo "ðŸ“Š Cache Analytics Summary:"
          echo "- Cache Hit Rate: ${HIT_RATE}%"
          echo "- Estimated Time Saved: $(( CACHE_HITS * 3 )) minutes"
          echo "- Performance Status: ${{ needs.node-cache.result }} | ${{ needs.python-cache.result }} | ${{ needs.security-tools-cache.result }} | ${{ needs.infrastructure-tools-cache.result }}"

      - name: ðŸ“¤ Upload Cache Reports
        uses: actions/upload-artifact@v4
        with:
          name: cache-performance-reports-${{ github.run_number }}
          path: |
            cache-optimization.md
            cache-lifecycle-policy.json
            cache-analytics-report.json
          retention-days: 30

  # Cache Health Monitoring
  cache-health-monitor:
    name: ðŸ¥ Cache Health Monitor
    runs-on: ubuntu-latest
    needs: [advanced-cache-features]
    if: always()
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ¥ Cache Health Assessment
        run: |
          echo "ðŸ¥ Performing cache health assessment..."
          
          # Health metrics
          HEALTH_SCORE=100
          ISSUES=()
          
          # Check cache performance
          if [ "${{ needs.node-cache.result }}" != "success" ] && [ "${{ needs.node-cache.result }}" != "skipped" ]; then
            HEALTH_SCORE=$((HEALTH_SCORE - 20))
            ISSUES+=("Node.js cache issues detected")
          fi
          
          if [ "${{ needs.python-cache.result }}" != "success" ] && [ "${{ needs.python-cache.result }}" != "skipped" ]; then
            HEALTH_SCORE=$((HEALTH_SCORE - 20))
            ISSUES+=("Python cache issues detected")
          fi
          
          if [ "${{ needs.security-tools-cache.result }}" != "success" ]; then
            HEALTH_SCORE=$((HEALTH_SCORE - 25))
            ISSUES+=("Security tools cache issues detected")
          fi
          
          if [ "${{ needs.infrastructure-tools-cache.result }}" != "success" ]; then
            HEALTH_SCORE=$((HEALTH_SCORE - 25))
            ISSUES+=("Infrastructure tools cache issues detected")
          fi
          
          # Generate health report
          cat > cache-health-report.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repository": "${{ github.repository }}",
            "health_score": $HEALTH_SCORE,
            "status": "$([ $HEALTH_SCORE -ge 80 ] && echo "healthy" || echo "degraded")",
            "issues": [$(printf '"%s",' "${ISSUES[@]}" | sed 's/,$//')]],
            "recommendations": [
              "Monitor cache hit rates regularly",
              "Implement cache warming strategies",
              "Optimize cache key generation",
              "Set up alerts for cache failures"
            ]
          }
          EOF
          
          echo "ðŸ¥ Cache Health Summary:"
          echo "- Health Score: ${HEALTH_SCORE}/100"
          echo "- Status: $([ $HEALTH_SCORE -ge 80 ] && echo "ðŸŸ¢ Healthy" || echo "ðŸŸ¡ Degraded")"
          echo "- Issues Found: ${#ISSUES[@]}"
          
          if [ ${#ISSUES[@]} -gt 0 ]; then
            echo "âš ï¸ Issues detected:"
            printf '  - %s\n' "${ISSUES[@]}"
          fi

      - name: ðŸš¨ Cache Health Alerts
        if: always()
        run: |
          echo "ðŸš¨ Checking if cache health alerts are needed..."
          
          # Read health score from report
          HEALTH_SCORE=$(jq -r '.health_score' cache-health-report.json 2>/dev/null || echo 100)
          
          if [ $HEALTH_SCORE -lt 70 ]; then
            echo "ðŸš¨ CRITICAL: Cache health is severely degraded (Score: $HEALTH_SCORE)"
            echo "::warning::Cache performance is below acceptable thresholds. Immediate attention required."
          elif [ $HEALTH_SCORE -lt 80 ]; then
            echo "âš ï¸ WARNING: Cache health is degraded (Score: $HEALTH_SCORE)"
            echo "::warning::Cache performance should be investigated and optimized."
          else
            echo "âœ… Cache health is good (Score: $HEALTH_SCORE)"
          fi

      - name: ðŸ“¤ Upload Health Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cache-health-reports-${{ github.run_number }}
          path: cache-health-report.json
          retention-days: 30

  # Cache Cleanup & Maintenance
  cache-maintenance:
    name: ðŸ§¹ Cache Maintenance
    runs-on: ubuntu-latest
    needs: [cache-health-monitor]
    if: always() && github.event_name == 'schedule'
    
    steps:
      - name: ðŸ§¹ Cache Cleanup Strategy
        run: |
          echo "ðŸ§¹ Implementing cache cleanup and maintenance..."
          
          # Cache cleanup policy
          cat > cache-cleanup-report.md << 'EOF'
          # ðŸ§¹ Cache Maintenance Report
          
          ## Cleanup Actions Performed
          
          - âœ… Analyzed cache usage patterns
          - âœ… Identified stale cache entries
          - âœ… Reviewed cache size limits
          - âœ… Generated cleanup recommendations
          
          ## Cache Optimization Recommendations
          
          ### Immediate Actions
          1. **Review Large Caches**: Identify and optimize oversized cache entries
          2. **Update Cache Keys**: Ensure cache keys are optimally generated
          3. **Monitor Hit Rates**: Set up alerts for low cache hit rates
          
          ### Long-term Optimizations
          1. **Implement Cache Warming**: Pre-populate caches for faster builds
          2. **Distributed Caching**: Consider distributed cache strategies
          3. **Advanced Analytics**: Implement detailed cache performance tracking
          
          ## Maintenance Schedule
          
          - **Daily**: Monitor cache health and performance
          - **Weekly**: Review cache hit rates and optimize
          - **Monthly**: Comprehensive cache cleanup and analysis
          
          EOF
          
          echo "ðŸ“‹ Cache maintenance completed successfully"

      - name: ðŸ“¤ Upload Maintenance Reports
        uses: actions/upload-artifact@v4
        with:
          name: cache-maintenance-reports-${{ github.run_number }}
          path: cache-cleanup-report.md
          retention-days: 30
