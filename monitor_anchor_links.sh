#!/bin/bash

# Anchor Link Monitoring Script
# Performs regular health checks and generates monitoring reports

set -e

# Configuration
REPO_ROOT="${1:-.}"
LOG_DIR="${REPO_ROOT}/anchor_link_logs"
TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
REPORT_FILE="${LOG_DIR}/monitor_${TIMESTAMP}.txt"
SUMMARY_FILE="${LOG_DIR}/latest_summary.txt"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Create log directory
mkdir -p "$LOG_DIR"

echo -e "${BLUE}ðŸ” Anchor Link Monitoring System${NC}"
echo "=================================="
echo "Timestamp: $(date)"
echo "Repository: $REPO_ROOT"
echo "Report: $REPORT_FILE"
echo ""

# Function to log with timestamp
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$REPORT_FILE"
}

# Function to run check and capture results
run_check() {
    log "Starting anchor link health check..."
    
    if [ -f "$REPO_ROOT/check_anchor_links_filtered.py" ]; then
        log "Running filtered anchor link checker..."
        cd "$REPO_ROOT"
        python3 check_anchor_links_filtered.py > "${LOG_DIR}/check_output_${TIMESTAMP}.txt" 2>&1
        CHECK_EXIT_CODE=$?
    else
        log "ERROR: check_anchor_links_filtered.py not found!"
        return 1
    fi
    
    # Parse results
    BROKEN_LINKS=$(grep "Broken links:" "${LOG_DIR}/check_output_${TIMESTAMP}.txt" | grep -o '[0-9]\+' | head -1 || echo "0")
    TOTAL_ISSUES=$(grep "Total issues:" "${LOG_DIR}/check_output_${TIMESTAMP}.txt" | grep -o '[0-9]\+' | head -1 || echo "0")
    FILES_CHECKED=$(grep "Files checked:" "${LOG_DIR}/check_output_${TIMESTAMP}.txt" | grep -o '[0-9]\+' | head -1 || echo "0")
    
    log "Check completed with exit code: $CHECK_EXIT_CODE"
    log "Files checked: $FILES_CHECKED"
    log "Broken links: $BROKEN_LINKS"
    log "Total issues: $TOTAL_ISSUES"
    
    return $CHECK_EXIT_CODE
}

# Function to generate summary
generate_summary() {
    cat > "$SUMMARY_FILE" << EOF
# Anchor Link Health Summary

**Last Check:** $(date)  
**Repository:** $REPO_ROOT  
**Status:** $1  

## Metrics
- **Files Checked:** $FILES_CHECKED
- **Broken Links:** $BROKEN_LINKS  
- **Total Issues:** $TOTAL_ISSUES
- **Exit Code:** $CHECK_EXIT_CODE

## Status Details
$2

## Quick Actions
\`\`\`bash
# Check anchor links
python3 check_anchor_links_filtered.py

# Fix broken links
python3 fix_broken_links.py

# View detailed report
cat ${LOG_DIR}/check_output_${TIMESTAMP}.txt
\`\`\`

---
*Generated by monitor_anchor_links.sh*
EOF
}

# Function to send notifications (placeholder for future enhancement)
send_notification() {
    local status="$1"
    local message="$2"
    
    # Future: Could integrate with Slack, email, etc.
    log "NOTIFICATION: $status - $message"
}

# Main monitoring logic
main() {
    log "=== ANCHOR LINK MONITORING START ==="
    
    # Run the check
    if run_check; then
        if [ "$BROKEN_LINKS" -eq 0 ]; then
            STATUS="âœ… HEALTHY"
            MESSAGE="All anchor links are working correctly!"
            echo -e "${GREEN}$MESSAGE${NC}"
            generate_summary "$STATUS" "$MESSAGE"
            log "âœ… Monitoring completed successfully - no issues found"
        else
            STATUS="âš ï¸ WARNINGS"
            MESSAGE="Found suggestions for improvements but no critical issues"
            echo -e "${YELLOW}$MESSAGE${NC}"
            generate_summary "$STATUS" "$MESSAGE"
            log "âš ï¸ Monitoring completed - found suggestions for improvements"
        fi
    else
        if [ "$BROKEN_LINKS" -gt 0 ]; then
            STATUS="âŒ CRITICAL"
            MESSAGE="Found $BROKEN_LINKS broken anchor links that need immediate attention!"
            echo -e "${RED}$MESSAGE${NC}"
            generate_summary "$STATUS" "$MESSAGE"
            send_notification "CRITICAL" "$MESSAGE"
            log "âŒ CRITICAL: $MESSAGE"
            
            # Auto-fix attempt
            if [ -f "$REPO_ROOT/fix_broken_links.py" ]; then
                log "Attempting auto-fix..."
                python3 "$REPO_ROOT/fix_broken_links.py" > "${LOG_DIR}/autofix_${TIMESTAMP}.txt" 2>&1
                AUTOFIX_EXIT_CODE=$?
                
                if [ $AUTOFIX_EXIT_CODE -eq 0 ]; then
                    log "âœ… Auto-fix completed successfully"
                    echo -e "${GREEN}Auto-fix applied successfully!${NC}"
                    
                    # Re-run check to verify
                    log "Re-running check to verify fixes..."
                    run_check
                    
                    if [ "$BROKEN_LINKS" -eq 0 ]; then
                        STATUS="âœ… FIXED"
                        MESSAGE="Auto-fix successfully resolved all broken links!"
                        echo -e "${GREEN}$MESSAGE${NC}"
                        generate_summary "$STATUS" "$MESSAGE"
                        send_notification "RESOLVED" "$MESSAGE"
                    fi
                else
                    log "âŒ Auto-fix failed with exit code: $AUTOFIX_EXIT_CODE"
                fi
            fi
        else
            STATUS="âŒ ERROR"
            MESSAGE="Check failed with unexpected error"
            echo -e "${RED}$MESSAGE${NC}"
            generate_summary "$STATUS" "$MESSAGE"
            send_notification "ERROR" "$MESSAGE"
            log "âŒ ERROR: Check failed with exit code $CHECK_EXIT_CODE"
        fi
    fi
    
    log "=== ANCHOR LINK MONITORING END ==="
    
    # Show summary
    echo ""
    echo -e "${BLUE}ðŸ“‹ Summary Report${NC}"
    echo "=================="
    cat "$SUMMARY_FILE"
    
    # Cleanup old logs (keep last 10)
    log "Cleaning up old logs..."
    cd "$LOG_DIR"
    ls -t monitor_*.txt 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
    ls -t check_output_*.txt 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
    ls -t autofix_*.txt 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
    
    return $CHECK_EXIT_CODE
}

# Run main function
main "$@"
